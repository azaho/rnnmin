import numpy as np# https://stackoverflow.com/questions/11788950/importing-numpy-into-functionsdef o_spikes(pref, stim, exponent, maxSpike, k):    # o_spikes: spike numbers per trial for orientation tuning cells    # r = o_spikes(pref, stim, exponent, k)     # pref: row vec for cells' preferred orientations    # stim: column vec for stimulus orientations    # exponent: scalar determining the widths of tuning. larger value for sharper tuning    # maxSpike: scalar for mean max spike number when pref = stim    # k: scalar for determining variance = k * mean    # spikes: different columuns for cells with different pref orintations    #         different rows for different stim orientations    np_ = pref.shape[0]# number of elements in pref    ns = stim.shape[0]# number of elements in stim        prefs = np.ones((ns,1)) @ pref[None,:]# ns x np array, (ns x 1) @ (1 x np)     stims = stim[:,None] @ np.ones((1,np_))# ns x np array, (ns x 1) @ (1 x np)         # mean spike numbers    meanSpike = maxSpike * (0.5*(np.cos(2*(prefs-stims)) + 1)) ** exponent# ns x np array        # sigma for noise    sigmaSpike = np.sqrt(k * meanSpike)        #spikes = normrnd(meanSpike, sigmaSpike)# ns x np array, matlab    spikes = np.random.normal(meanSpike, sigmaSpike)# ns x np array, python        # no negative spike numbers    spikes[spikes < 0] = 0# ns x np array    return spikesif __name__ == "__main__":# execute example code below if running .py file as the main program, but don't execute code below if importing function    import matplotlib.pyplot as plt    from matplotlib import cm    np.random.seed(123)# set random seed for reproducible results         n_orient = 32# number of cells with different preferred orientations    #pref = np.pi*(0:n_orient-1)/n_orient# preferred orientations uniformly distributed in [0, pi), matlab     pref = np.pi * np.arange(0,n_orient,1) / n_orient# preferred orientations uniformly distributed in [0, pi), python     exponent = 4# 4, exponent for the tuning curve; larger value, sharper tuning.    max_rate = 50/12.5# 50, mean max firing rate in spikes/sec at pref orientation    duration = 0.5# stimulus duration in sec    max_spike_num = max_rate*duration# mean number of spikes at preferred    #k = 1# 2, const for determining variance in spike number, Poisson k = 1.        k = 0# no noise in input, focus on how perfect input is stored in memory and then corrupted over time by noise in RNN    stimulusangles_degrees = np.array([10, 190])# (numtrials, ), angles in degrees    stimulusangles = stimulusangles_degrees*np.pi/180# (numtrials,), angles in radians    spikes = o_spikes(pref, stimulusangles, exponent, max_spike_num, k)# numtrials x n_orient array, response (spikes per trial) of orientation tuned cells    numtrials = stimulusangles_degrees.shape[0]        fig, ax = plt.subplots()    fontsize = 14    numcurves = numtrials    jet = cm.get_cmap('jet', numcurves)    colormap = jet(range(numcurves))# (numcurves, 4) array columns 1,2,3 are the RGB values, column 4 sets the transparency/alpha, datapoint[0] has color colormap[0,:]    colormap[0,:] = np.array([0, 0, 1, 1]); colormap[-1,:] = np.array([1, 0, 0, 1]);# colormap[0,:] is blue, colormap[-1,:] is red    for itrial in range(numtrials):        ax.plot(pref*180/np.pi, spikes[itrial,:], '.', c=colormap[itrial,:], markersize=15, label=f'Response to stimulus at {stimulusangles_degrees[itrial]}\N{DEGREE SIGN}')    ax.legend(frameon=True, framealpha=0.9, loc='best', fontsize=fontsize)    ax.set_xlabel('Preferred orientation (deg)', fontsize=fontsize)    ax.set_ylabel('Number of spikes', fontsize=fontsize)    ax.set_title(f'{n_orient} neurons with preferred orientations distributed\n'                 'uniformly between 0 and 180 degrees', fontsize=fontsize)    ax.spines['top'].set_visible(False); ax.spines['right'].set_visible(False);# ax.spines['bottom'].set_visible(False); ax.spines['left'].set_visible(False)    ax.tick_params(axis='both', labelsize=fontsize)    plt.show()                            